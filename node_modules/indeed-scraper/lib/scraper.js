const request = require('request-promise');
const cheerio = require('cheerio');

module.exports.query = function(queryObject){
  const q = new Query(queryObject);
  return q.getJobs();
};

function Query(qo){
  // query variables
  this.query = qo.query || '';
  this.location = qo.location || '';
  this.radius = qo.radius || '25';
  this.level = qo.level || '';
  this.maxAge = qo.maxAge || '';
  this.sort = qo.sort || '';
  this.jobType = qo.jobType || '';
  this.publisher = qo.publisher || '';

  // internal variables
  this.start = 0;
  this.limit = Number(qo.limit) || 0;
}

Query.prototype.url = function(){
  let q = 'https://api.indeed.com/ads/apisearch';
  q += '?publisher=' + this.publisher;
  q += '&q=' + this.query;
  q += '&l=' + this._locationNameForWeb();
  q += '&radius=' + this.radius;
  q += '&fromage=' + this.maxAge;
  q += '&sort=' + this.sort;
  q += '&jt=' + this.jobType;
  q += '&start=' + this.start;
  q += '&limit=25';
  q += '&format=json';
  q += '&v=2';
  return q;
}

Query.prototype._locationNameForWeb = function(){
  return this.location.replace(' ', '+').replace(',', '%2C');
};

/* Gets all the desired jobs for the city */
Query.prototype.getJobs = function(){
  return new Promise((resolve, reject) => {
    /* Recursive function that gets jobs until it can't anymore (Or shouldn't) */
    function getSomeJobs(self, jobs) {
      const options = {
        url: self.url(),
        json: true,
      }
      request(options, (error, response, data) => {
        const jobsWithUrls = getExternalUrls(data.results);
        jobs = jobs.concat(jobsWithUrls);
        if (error !== null) {
          // Got an error so reject
          reject(Error);
        } else {
          // If we reach the limit stop looping
          if (self.limit != 0 && jobs.length >= self.limit) {
            while(jobs.length != self.limit) jobs.pop();
            resolve(jobs);
          } else {
            // Continue getting more jobs
            self.start += 25;
            getSomeJobs(self, jobs);
          }
        }
      });
    }

    getSomeJobs(this, []);
  });
}

function getExternalUrls(jobs) {
  jobs.forEach((job, index) => {
    const options = {
      url: job.url,
      transform: body => cheerio.load(body),
    }
    request(options).then(function($) {
      const internalBusinessUrl = $('.jobsearch-ViewJobLayout-companyPromo').find('a').attr('href');
      if (typeof internalBusinessUrl !== 'undefined') {
        jobs[index].url = internalBusinessUrl.split('/').slice(0, -1).join('/') + '/about';
        const options = {
          url: jobs[index].url,
          transform: body => cheerio.load(body),
        }
        request(options).then(function($) {
          const externalBusinessUrl = $('#cmp-company-details-sidebar a:contains("website")').attr('href');
          if (typeof externalBusinessUrl !== 'undefined') {
            jobs[index].url = externalBusinessUrl;
          }
        });
      }
    });
  });
  return jobs;
}
